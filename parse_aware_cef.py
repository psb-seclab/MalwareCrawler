"""
	Brian O'Connell
	TaaSera

	Script to parse CEF log into MySQL database

"""

import os
import re
import MySQLdb
import sys
import datetime
import time

#MONTHS = {'Jan':'01','Feb':'02','Mar':'03','Apr':'04','May':'05','Jun':'06','Jul':'07','Aug':'08','Sep':'09','Oct':'10','Nov':'11','Dec':'12'}
MONTHS = {'Jan':1,'Feb':2,'Mar':3,'Apr':4,'May':5,'Jun':6,'Jul':7,'Aug':8,'Sep':9,'Oct':10,'Nov':11,'Dec':12}


def connect_mysql (username, password, database, sql_host='127.0.0.1', sql_port=3306):

	try:
		sql_connection = MySQLdb.connect(host=sql_host, port=sql_port, user=username, passwd=password, db=database)
	except MySQLdb.Error as e:
		print(e)

	return sql_connection


def sid_in_DB (sql_cursor, sid_str):
	"""	Return id of sid in table if exists
		Return 0 if does not exist
		Return negative error code on error
	"""

	if sid_str in sid_in_DB.cached_sids.keys():
		return sid_in_DB.cached_sids[sid_str]

	sql_sid_query = "select id from sid where sid_str=%s"

	try:
		sql_cursor.execute(sql_sid_query, [sid_str])
	except Exception as e:
		sys.stderr.write(sid_str)
		sys.stderr.write("Exception querying for sid %s: " % (sid_str) + str(e) + "\n")
		return -1

	if sql_cursor.rowcount == 1:
		sid_id = sql_cursor.fetchone()[0]
		sid_in_DB.cached_sids[sid_str] = sid_id
		return sid_id
	elif sql_cursor.rowcount > 1:
		sys.stderr.write("Error: more than one entry for sid %s\n" % (sid_str))
		return -2
	return 0


def write_sid_sql (sql_write_cursor, sid_str, category, rule_type, dialog, msg_text):
	"""
	"""
	sql_sid_insert = "insert into sid (sid_str,category,rule_type,dialog,msg_text) values (%s,%s,%s,%s,%s)"

	try:
		sql_sid_write_result = sql_write_cursor.execute(sql_sid_insert, (sid_str,category,rule_type,dialog,msg_text))
	except Exception as e:
		sys.stderr.write("Exception in SQL sid insert for (sid_str,category,rule_type,dialog,msg_text) (%s,%s,%s,%s,%s): %s\n" % (sid_str,category,rule_type,dialog,msg_text,str(e)))
		return -2

	return sql_sid_write_result


def write_event_sql (sql_write_cursor):
	return


def create_profile_sql (sql_write_cursor,log_datetime):
	""" Return id of new profile on success
		Return negative error code on failure
	"""
	sql_profile_insert = "insert into Aware7B1C_profile (log_datetime) values (%s)"

	try:
		sql_profile_insert_result = sql_write_cursor.execute(sql_profile_insert, (log_datetime,))
	except Exception as e:
		sys.stderr.write("Exception in SQL profile insert for (log_datetime) (%s): %s\n" % (log_datetime,str(e)))
		return -2

	return


def finalize_profile_sql (sql_awareDB_write_cursor,profile_id,profile_start,profile_finish):
	return


if __name__ == '__main__':

	#cef_file = open('AWARE_cef_20150709_050324.log', 'r')
	if len(sys.argv) > 1:
		filename = sys.argv[1]
	else:
		filename = 'Aware7B1C_temp.log'

	if os.path.isfile(filename):
		cef_file = open(filename, 'r')
	else:
		sys.stderr.write("File does not exist: %s\n" % filename)
		sys.exit(1)

	sql_awareDB = connect_mysql(username='cuckoo', password='sANDb4ch$', database='sandbox')
	sql_awareDB_read_cursor = sql_awareDB.cursor()
	sql_awareDB_write_cursor = sql_awareDB.cursor()

	sid_in_DB.cached_sids = {}

	# Profiles are created from consecutive events in syslog with same datetime in log
	# We can assume entire cef_fields[0] will be the same (month, day, time, CEF: 0)
	# Finalize current profile and get new profile info when string changes
	profile_cef_field0 = ""

	# Current profile seconds since epoch
	profile_log_datetime = 0
	profile_id = 0
	# For each profile keep track of earliest start time, last rt time among events
	# Milliseconds since epoch
	profile_start = 9999999999999			# Initialize start higher than possible
	profile_finish = 0 						# Initialize finish lower than possible

	for cef_line in cef_file:

		# Set this on every iteration. If true at end of iteration, write entry to sid table
		write_new_sid = False

 		# Split CEF log line into its segments
		cef_fields = cef_line.split('|', 7)
		
		# If split of cef_fields only results in one item
		if (len(cef_fields) == 1):
			# Error if it's not a newline
			if (cef_line != chr(10)):
				sys.stderr.write("Error parsing CEF line with only one field: %s\n" % cef_line)
				continue
			# OK if it's a newline
			else:
				continue

		# Account for possibility that escaped pipe exists in a field
		if cef_fields[7].find('start') != 0:
			# TODO: Write function to handle situations where CEF log has escaped pipes
			#       (one of the cef_fields has a | in the data)
			sys.stderr.write("Error. CEF field 7 does not begin with 'start': %s\n" % cef_line)
			continue

		sid_str = cef_fields[4]
		category = cef_fields[5]
		severity = int(cef_fields[6])

		cef_last_field_iter = iter(re.split('([^\s]+)=', cef_fields[7]))
		cef_last_field_iter.next()


		for cef_field7_item in cef_last_field_iter:

			cef_field7_var = cef_field7_item
			cef_field7_value = cef_last_field_iter.next().rstrip(' ')

			if cef_field7_var == 'start':
				event_start = cef_field7_value
				continue

			if cef_field7_var == 'rt':
				event_finish = cef_field7_value
				continue

			if cef_field7_var == 'msg':
				sid_id = sid_in_DB(sql_awareDB_read_cursor, sid_str)
				if sid_id == 0:
					write_new_sid = True
					dialog = cef_field7_value.split(' ',1)[0]
					msg_text = cef_field7_value.split('] ')[1]
					msg_text = msg_text.split(',')[0].split('[')[0].split('[')[0].split('pcap')[0].split('(')[0]
				elif sid_id < 0:
					print "Skipping line due to error: %s\n" % (cef_line)
					continue
				continue

			if cef_field7_var == 'src':
				src = cef_field7_value
				continue

			if cef_field7_var == 'proto':
				proto = cef_field7_value
				continue

			if cef_field7_var == 'cs11':
				rule_type = cef_field7_value
				continue


		if write_new_sid == True:
			sid_id = write_sid_sql(sql_awareDB_write_cursor,sid_str,category,rule_type,dialog,msg_text)

			if sid_id < 1:
				sys.stderr.write("Failed to insert to sid (sid_str,category,rule_type,dialog,msg_text) values (%s,%s,%s,%s,%s)\n" % (sid_str,category,rule_type,dialog,msg_text))

		# If string changes, new profile. Finalize current profile and get new profile info
		if cef_fields[0] != profile_cef_field0:
			# If first profile (empty string), set marker string and move on
			if profile_cef_field0 == '':
				profile_cef_field0 = cef_fields[0]
			# If not first profile, update current profile
			else:
				finalize_profile_sql(sql_awareDB_write_cursor,profile_id,profile_start,profile_finish)
				profile_start = event_start			# Initially set profile start time according to first event
				profile_finish = event_finish		# Same for finish

			try:
				cef0_month_abbrv, cef0_day, cef0_profile_time, cef0_sensor = cef_fields[0].split('CEF')[0].split()
			except Exception as e:
				print e
				print cef_fields[0]
				continue

			profile_month = MONTHS[cef0_month_abbrv]
			#profile_day = cef0_day if len(cef0_day) == 2 else '0'+cef0_day
			profile_day = int(cef0_day)
			profile_hour,profile_minute,profile_second = (int(item) for item in cef0_profile_time.split(':'))
			now_year = int(time.strftime("%Y"))
			now_month = int(time.strftime("%m"))

			# If profile is dated December and it is now January, profile took place last year
			if (now_month == 1) and (profile_month == 12):
				profile_year = now_year - 1
			# Normally, profile year = current year
			else:
				profile_year = now_year

			profile_log_datetime = datetime.datetime(profile_year,profile_month,profile_day,profile_hour,profile_minute,profile_second)

			profile_id = create_profile_sql(sql_awareDB_write_cursor,profile_log_datetime)
		# If cef_field[0] still equal to profile_cef_field0 it's same profile, update start, finish dateimes if necessary
		else:
			if event_start < profile_start:
				profile_start = event_start
			if event_finish > profile_finish:
				profile_finish = event_finish

		try:
			sql_awareDB.commit()
			sid_in_DB.cached_sids[sid_str] = sid_id
		except Exception as e:
			sys.stderr.write("Exception on commit %s" % (str(e)))


	sql_awareDB_read_cursor.close()
	sql_awareDB.close()
	cef_file.close()